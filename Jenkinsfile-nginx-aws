pipeline {
    agent { label 'local' }  // Ensure this runs on the local node
    parameters {
        string(name: 'NGINX_CONF', description: 'Path to the Nginx configuration file')
        string(name: 'SERVER_NAME', description: 'Server name for the Nginx configuration')
        string(name: 'DOCKER_PORT', description: 'Docker container port to be proxied by Nginx')
        string(name: 'AWS_PUBLIC_IP', description: 'Public IP of the AWS EC2 instance running the service')
        string(name: 'PROJECT_NAME_WITH_DASH', defaultValue: 'numerical', description: 'Project name with dashes, used for Kubernetes deployment name')
        string(name: 'ENV_PROJECT_NAME', defaultValue: 'numerical', description: 'Docker container/project name')
    }
    stages {
        stage('Check & Create Nginx Configuration') {
            steps {
                script {
                    // Check if the Nginx configuration file exists
                    def configExists = sh(script: "test -f ${params.NGINX_CONF} && echo 'exists' || echo 'not exists'", returnStdout: true).trim()

                    if (configExists == 'not exists') {
                        echo "Nginx configuration file does not exist. Creating it now..."

                        // Create or overwrite the NGINX_CONF file with the content of nginx.conf using sudo tee
                        sh "sudo cat nginx.conf | sudo tee ${params.NGINX_CONF} > /dev/null"

                        // Replace placeholders in the configuration file
                        sh "sudo sed -i 's|SERVER_NAME|${params.SERVER_NAME}|g' ${params.NGINX_CONF}"
                        sh "sudo sed -i 's|DOCKER_PORT|${params.DOCKER_PORT}|g' ${params.NGINX_CONF}"

                        echo "Nginx configuration file created."

                        // Enable the new Nginx configuration
                        sh "sudo ln -sf ${params.NGINX_CONF} /etc/nginx/sites-enabled/"
                    } else {
                        echo "Nginx configuration file already exists."
                    }
                }
            }
        }
        
        stage('Update Nginx for AWS Service') {
            steps {
                script {
                    echo "Checking AWS service status..."
                    
                    // Validate parameters
                    if (!params.AWS_PUBLIC_IP || !params.DOCKER_PORT) {
                        error("AWS_PUBLIC_IP and DOCKER_PORT must be provided.")
                    }

                    // Check if the service is running on the AWS node by fetching HTTP status
                    def httpStatus = sh(script: "curl -s -o /dev/null -w '%{http_code}' http://${params.AWS_PUBLIC_IP}:${params.DOCKER_PORT}", returnStdout: true).trim()
                    echo "HTTP Status: ${httpStatus}"

                    if (httpStatus == '200') {
                        echo "Service on AWS is available. Updating Nginx configuration on local node..."

                        // Update the Nginx configuration to point to the AWS IP and reload Nginx
                        sh """
                            sudo sed -i 's|proxy_pass .*;|proxy_pass http://${params.AWS_PUBLIC_IP}:${params.DOCKER_PORT};|' ${params.NGINX_CONF}
                            sudo nginx -s reload
                        """
                        echo 'Nginx configuration updated and reloaded successfully.'
                    } else {
                        echo "Service on AWS is not available. Nginx configuration not updated."
                        error("AWS service unavailable, HTTP Status: ${httpStatus}")
                    }
                }
            }
        }
        
        stage('Scale Down Kubernetes and Remove Local Docker') {
            steps {
                script {
                    echo "Scaling down Kubernetes deployment if it exists..."
                    sh """
                        replicas=\$(kubectl get deployment ${PROJECT_NAME_WITH_DASH}-app -o=jsonpath='{.spec.replicas}') || true
                        if [ "\$replicas" != "" ] && [ \$replicas -gt 0 ]; then
                            kubectl scale deployment ${PROJECT_NAME_WITH_DASH}-app --replicas=0
                            echo 'Kubernetes deployment scaled down successfully.'
                        else
                            echo 'No running Kubernetes deployment to scale down.'
                        fi
                    """

                    echo "Checking for running local Docker container for project ${ENV_PROJECT_NAME}..."
                    sh """
                        DOCKER_CONTAINER=\$(docker ps -q -f name=${ENV_PROJECT_NAME})
                        if [ "\$DOCKER_CONTAINER" ]; then
                            echo "Docker container ${ENV_PROJECT_NAME} is running. Stopping and removing it..."
                            docker rm -f ${ENV_PROJECT_NAME}
                            if [ \$? -ne 0 ]; then
                                echo "Failed to remove Docker container ${ENV_PROJECT_NAME}"
                                exit 1
                            fi
                        else
                            echo "Docker container ${ENV_PROJECT_NAME} is not running. Skipping removal."
                        fi
                    """
                }
            }
        }
    }
    post {
        success {
            echo "Nginx update process completed successfully."
        }
        failure {
            echo "Nginx update process failed."
        }
    }
}
